package main

/*
	Реализовать паттерн «состояние».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern
*/

/*
	Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости
	от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

	Плюсы:
	- Гибкость и расширяемость. Добавление новых состояний или изменение поведения существующих состояний не влияет
    на другие части кода
	- Разделение ответственности. Паттерн позволяет разделить ответственность за разные аспекты
    поведения объекта между разными классами состояний, что способствует соблюдению принципа единственной
    ответственности

	Минусы:
	- Увеличение числа классов. Использование паттерна может привести к созданию большого
    количества классов, особенно если у объекта много состояний
	- Потеря состояния при смене контекста. Если не учитывать текущее состояние при копировании или сериализации объекта,
    может возникнуть потеря информации о состоянии
	-Сложность отслеживания состояний. В больших системах может быть сложно отслеживать все переходы между
    состояниями и правильно управлять ими
*/

type State interface {
	methodA()
	methodB()
}

type Context struct {
	stateA State
	stateB State
	stateC State

	current State
}

func newContext() *Context {
	return &Context{
		stateA:  &StateA{},
		stateB:  &StateB{},
		stateC:  &StateC{},
		current: &StateA{},
	}
}

func (ctx *Context) setState(s State) {
	ctx.current = s
}

type StateA struct {
	ctx *Context
}

func (s *StateA) methodA() {
}

func (s *StateA) methodB() {
}

type StateB struct {
	ctx *Context
}

func (s *StateB) methodA() {
}

func (s *StateB) methodB() {
}

type StateC struct {
	ctx *Context
}

func (s *StateC) methodA() {
}

func (s *StateC) methodB() {
}
